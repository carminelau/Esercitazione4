/*Specifiche grammaticali e lessicali del nostro linguaggio MyFun


  ************* Specifica grammaticale ****************

    Program ::= VarDeclList FunList Main

    VarDeclList ::= /* empty */
    /*	| VardDecl VarDeclList

    Main ::= MAIN VarDeclList StatList END MAIN SEMI

    FunList ::= /* empty */
    /*	| Fun FunList

    VarDecl ::= Type IdListInit SEMI
        | VAR IdListInitObbl SEMI

    Type ::= INTEGER | BOOL | REAL | STRING

    IdListInit ::= ID
        | IdListInit COMMA ID
        | ID ASSIGN Expr
        | IdListInit COMMA ID ASSIGN Expr

    IdListInitObbl ::= ID ASSIGN Const
        | IdListInitObbl COMMA ID ASSIGN Const

    Const ::= INTEGER_CONST | REAL_CONST | BOOL_CONST | STRING_CONST

    Fun := FUN ID LPAR ParamDeclList RPAR COLON Type
            VarDeclList StatList END FUN SEMI
        | FUN ID LPAR ParamDeclList RPAR
            VarDeclList StatList END FUN SEMI


    ParamDeclList ::= /*empty */
    /*	| NonEmptyParamDeclList

    NonEmptyParamDeclList ::= ParDecl
        | NonEmptyParamDeclList COMMA ParDecl

    ParDecl ::= Type ID
        | OUT Type ID

    StatList ::= Stat
         | Stat StatList

    Stat ::= IfStat SEMI
        | WhileStat SEMI
        | ReadStat SEMI
        | WriteStat SEMI
        | AssignStat SEMI
        | CallFun SEMI
        | RETURN Expr SEMI
        | /* empty */
    /*
    IfStat ::= IF Expr THEN VarDeclList StatList Else END IF

    Else ::= /* empty */
    /*	| ELSE VarDeclList  StatList

    WhileStat ::= WHILE Expr LOOP VarDeclList  StatList END LOOP

    ReadStat ::= READ IdList Expr // Expr deve essere di tipo stringa
        | READ IdList

    IdList ::= ID
        | IdList COMMA ID

    WriteStat ::=  WRITE  Expr
        | WRITELN  Expr
        | WRITET  Expr
        | WRITEB  Expr


    AssignStat ::=  ID ASSIGN Expr

    CallFun ::= ID LPAR ExprList RPAR
        | ID LPAR RPAR

    ExprList ::= Expr
        | Expr COMMA ExprList
        | OUTPAR ID
        | OUTPAR ID COMMA ExprList

    Expr ::= TRUE
        | FALSE
        | INTEGER_CONST
        | REAL_CONST
        | STRING_CONST
        | ID
        | CallFun
        | Expr  PLUS Expr
        | Expr  MINUS Expr
        | Expr  TIMES Expr
        | Expr  DIV Expr
        | Expr  DIVINT Expr
        | Expr  AND Expr
        | Expr POW Expr
        | Expr STR_CONCAT Expr
        | Expr  OR Expr
        | Expr  GT Expr
        | Expr  GE Expr
        | Expr  LT Expr
        | Expr  LE Expr
        | Expr  EQ Expr
        | Expr  NE Expr
        | MINUS Expr
        | NOT Expr
        | LPAR Expr RPAR
*/


package generated;
import java_cup.runtime.*;
import java.util.*;
import syntax.*;
import syntax.statements.*;
import syntax.expression.*;
import syntax.expression.binary.arithmetic.*;
import syntax.expression.binary.relation.*;
import syntax.expression.unary.*;
import syntax.expression.constant.*;
import syntax.types.*;


class Parser;

parser code{:

    public void report_error(String msg, Object info) {
      Symbol sym = (Symbol)info;
      System.out.println(msg + ": " + symbl_name_from_id(sym.sym));
    }

    public void syntax_error(Symbol cur_token) {
      System.out.println("Syntax error: " + symbl_name_from_id(cur_token.sym));
    }

:}

/*Terminal*/
terminal String MAIN,
                ID,
               	INTEGER,
               	STRING,
               	REAL,
               	BOOL,
               	LPAR,
               	RPAR,
               	COLON,
               	FUN,
               	END,
               	IF,
               	THEN,
               	ELSE,
               	WHILE,
               	LOOP,
               	READ,
               	WRITE,
               	WRITELN,
               	WRITEB,
               	WRITET,
               	ASSIGN,
               	PLUS,
               	MINUS,
               	TIMES,
               	DIVINT,
               	DIV,
               	POW,
               	STR_CONCAT,
               	EQ,
               	NE,
               	LT,
               	LE,
               	GT,
               	GE,
               	AND,
               	OR,
               	NOT,
               	NULL,
                STRING_CONST,
                SEMI,
               	COMMA,
               	UMINUS,
               	RETURN,
               	OUTPAR,
               	OUT,
               	VAR,
               	UMINUS;

terminal int INTEGER_CONST;
terminal double REAL_CONST;
terminal boolean  TRUE, FALSE;

//Non terminali

non terminal      Program         	             Program;
non terminal      ArrayList<VarDecl>             VarDeclList;
non terminal      Main                           Main;
non terminal      ArrayList<Fun>                 FunList;
non terminal      VarDecl                        VarDecl;
non terminal      Type                           Type;
non terminal      ArrayList<IdInit>              IdListInit;
non terminal      ArrayList<IdInitObbl>          IdListInitObbl;
non terminal      Const                          Const ;
non terminal      Fun                            Fun;
non terminal      ArrayList<ParamDecl>           ParamDeclList;
non terminal      ArrayList<NonEmptyParamDecl>   NonEmptyParamDeclList ;
non terminal      ParDecl                        ParDecl;
non terminal      ArrayList<Stat>                StatList;
non terminal      Stat                           Stat;
non terminal      If                             IfStat;
non terminal      Else                           Else;
non terminal      While                          WhileStat;
non terminal      Read                           ReadStat;
non terminal      Id                             IdStat;
non terminal      Write                          WriteStat;
non terminal      Assign                         AssignStat;
non terminal      CallFun                        CallFun;
non terminal      ArrayList<Expr>                ExprList;
non terminal      Expr                           Expr;

// Precendenze:: partendo dal basso (precedenza maggiore) a salire (precedenza minore)
precedence left OR;
precedence left AND;
precedence right NOT;
precedence nonassoc EQ, NE, LT, LE, GT, GE;
precedence left STR_CONCAT;
precedence left PLUS, MINUS;
precedence left TIMES,DIV, DIVINT;
precedence right POW;
precedence left LPAR, RPAR;


/*Program ::= VarDeclList FunList Main */
Program ::= VarDeclList:vardecllist_ FunList:funlist_ Main:main_
            {:
                RESULT = new Program(main_left,main_right,vardecllist_,funlist_,main_);
            :}
            ;

/* VarDeclList ::= empty  | VardDecl VarDeclList */
VarDeclList ::= VarDecl:vardecl_ VarDeclList:vardecllist_
                {:
                    vardecllist_.add(vardecl_);
                    RESULT = vardecllist_;
                :}
                |
                //epsilon
                ;

/* Main ::= MAIN VarDeclList StatList END MAIN SEMI */
Main ::= MAIN VarDeclList:vardecllist_ StatList:statlist_ END MAIN SEMI
        {:
            RESULT= new Main(vardeclist_left,vardecllist_right, vardecllist_, statlist_);
        :}
        ;

// FunList ::= Fun FunList
//    | /* empty */

FunList ::= Fun:fun_ FunList:funlist_
            {:
                funlist_.add(fun_);
                RESULT = funlist_;
            :}
            |
            //epsilon
            ;

// VarDecl ::= Type IdListInit SEMI
//        | VAR IdListInitObbl SEMI

VarDecl ::= Type:type_  IdListInitd:idlistinit_ SEMI
            {:
                RESULT = new VarDecl(type_left,type_right,type_, idlistinit_);
            :}
            |
            VAR IdListInitObbl:idlistobbl_ SEMI
            {:
                RESULT = new VarDecl(idlistobbl_left, idlistobbl_right, idlistobbl_);
            :}
            ;

// Const ::= INTEGER_CONST | REAL_CONST | BOOL_CONST | STRING_CONST
Const ::= INTEGER_CONST:integerconst_
        {:
            RESULT = new PrimitiveType(integerconst_left, integerconst_right, "INTEGER_CONST");
        :}
        |
        REAL_CONST:realconst_
        {:
            RESULT = new PrimitiveType(realconst_left, realconst_right, "REAL_CONST");
        :}
        |
        BOOL_CONST:boolconst_
        {:
            RESULT = new PrimitiveType(boolconst_left, boolconst_right, "BOOL_CONST");
        :}
        |
        STRING_CONST:stringconst_
        {:
            RESULT = new PrimitiveType(stringconst_left, stringconst_right, "STRING_CONST");
        :}
        ;

//Fun := FUN ID LPAR ParamDeclList RPAR COLON Type
  //            VarDeclList StatList END FUN SEMI
  //        | FUN ID LPAR ParamDeclList RPAR
  //            VarDeclList StatList END FUN SEMI
 Fun ::= FUN:fun_ ID:Id_ LPAR ParamDeclist: paramdeclist_ RPAR COLN Type:type_ VarDeclist: vardeclist_ StatList: stalist_ END DUN SEMI
        {:
            RESULT = new Fun(fun_left, fun_right, new Id(Id_left,Id_right,Id_),paramdeclist_, vardeclist_, statlist_);
        :}
        |
        FUN:fun_ ID:Id_ LPAR ParamDeclList:paramdeclist_ RPAR VarDeclList:vardeclist_ StatList:statlist END FUN SEMI
        {:
            RESULT = new Fun(fun_left,fun_right, new Id(Id_left,Id_right,Id_), paramdeclist_, vardeclist_,statlist_);
        :}
        ;

        //ParamDeclList ::= /*empty */
                  //    /*	| NonEmptyParamDeclList
ParamDeclList ::= NonEmptyParamDeclList: nonemptyparamdeclist_
        {:
            RESULT = new ParamDeclist( nonemptyparamdeclist_left, nonemptyparamdeclist_right, nonemptyparamdeclist_);
        :}
        |
        //EPSILON
        ;

//NonEmptyParamDeclList ::= ParDecl
  //        | NonEmptyParamDeclList COMMA ParDecl
NonEmptyParamDeclList ::= ParDecl: pardecl_
        {:
            RESULT = new ArrayList<ParDecl>();
            RESULT.add(pardecl_);
        :}
        |
        NonEmptyParamDeclist: nonemptyparamdeclist_ COMMA ParDecl: pardecl_
        {:
            nonemptyparamdeclist_.add(pardecl_);
            RESULT = nonemptyparamdeclist_;
        :}
        ;

        // ParDecl ::= Type ID
          //        | OUT Type ID
ParDecl::= Type: type_ ID
        {:
            RESULT = new ParDecl(type_left, type_right, type_);
        :}
        |
        OUT Type: type_ ID
        {:
            RESULT = new ParDecl(type_left, type_right, type_);
        :}
        ;

//StatList ::= Stat
  //         | Stat StatList
StatList::= Stat: stat_
    {:
        RESULT = new ArrayList<Stat>();
        RESULT.add(stat_);
    :}
    |
    Stat:stat_ Statlist: statlist_
    {:
        statlist_.add(stat_);
        RESULT = statlist_;
    :}
    ;

//Stat ::= IfStat SEMI
  //        | WhileStat SEMI
  //        | ReadStat SEMI
  //        | WriteStat SEMI
  //        | AssignStat SEMI
  //        | CallFun SEMI
  //        | RETURN Expr SEMI
  //        | /* empty */

Stat::= IfStat: ifstat_ SEMI
        {:
            RESULT = new Stat(ifstat_left,ifstat_right, ifstat_);
        :}
    |
    WhileStat: whilestat_ SEMI
        {:
            RESULT = new Stat(whilestat_left, whilestat_right, whilestat_);
        :}
    |
    ReadStat: readstat_ SEMI
        {:
            RESULT = new Stat(readstat_left, readstat_right, readstat_);
        :}
        |
    WriteStat: writestat_ SEMI
        {:
            RESULT = new Stat(writestat_left, writestat_right, writestat_);
        :}
        |
    AssignStat: assignstat_ SEMI
        {:
        RESULT = new Stat(assignstat_left, assignstat_right, assignstat_);
        :}
        |
    CallFun: callfun_ SEMI
        {:
        RESULT = new Stat(callfun_left, callfun_right, callfun_);
        :}
        |
    RETURN Expr:expr_ SEMI
        {:
        RESULT = new Stat(expr_left, expr_right, expr_);
        :}
        |
        //epsilon
        ;

//IfStat ::= IF Expr THEN VarDeclList StatList Else END IF
IfStat::= IF Expr:expr_ THEN VarDeclList:vardecllist_ StatList: statlist_ Else:else_ END IF
        {:
        RESULT = new IfStat(expr_left, expr_right, expr_, vardecllist_, statlist_, else_);
        :}
        ;

//Else ::= /* empty */
  //    /*	| ELSE VarDeclList  StatList
Else::= ELSE VarDeclList: vardecllist_ StatList: statlist_
        {:
            RESULT = new Else(vardecllist_left, vardecllist_right, vardecllist_, statlist_);
        :}
        |
        //epsilon
        ;

// WhileStat ::= WHILE Expr LOOP VarDeclList  StatList END LOOP
WhileStat::= WHILE Expr:expr_ LOOP VarDeclList: vardecllist_ StatList: statlist_ END LOOP
        {:
            RESULT = new WhileStat(expr_left, expr_right, expr_, vardecllist_, statlist_);
        :}
        ;

// WhileStat ::= WHILE Expr LOOP VarDeclList  StatList END LOOP
WhileStat ::= WHILE Expr: expr_ LOOP VarDeclList:vardecllist_  StatList:statlist_ END LOOP
        {:
            RESULT = new WhileStat(expr_left, expr_right, expr_, vardecllist_, statlist_);
        :}
        ;


//    ReadStat ::= READ IdList Expr // Expr deve essere di tipo stringa
//        | READ IdList
ReadStat ::= READ IdList:idlist_ Expr:expr_
        {:
            RESULT = new ReadStat(idlist_left,idlist_right,idlist_,expr_);
        :}
        ;


//    IdList ::= ID
//        | IdList COMMA ID
IdList::= ID:id_
        {:
            RESULT = new ArrayList<Id>();
            RESULT.add(new Id(id_left,id_right , id_));
        :}
        |
        IdList:idlist_ COMMA ID
        {:
            RESULT = new IdList(idlist_left,idlist_right,idlist_);
        :}
        ;



//WriteStat ::=  WRITE  Expr
  //        | WRITELN  Expr
  //        | WRITET  Expr
  //        | WRITEB  Expr
WriteStat ::=  WRITE  Expr:expr_
        {:
            RESULT = new WriteStat(expr_left, expr_right, expr_);
        :}
        |
        WRITELN  Expr:expr_
        {:
            RESULT = new WriteLnStat(expr_left, expr_right, expr_);
        :}
        |
        WRITET  Expr:expr_
        {:
            RESULT = new WriteTStat(expr_left, expr_right, expr_);
        :}
        |
        WRITEB  Expr:expr_
        {:
            RESULT = new WriteBStat(expr_left, expr_right, expr_);
        :}
        ;


//AssignStat ::=  ID ASSIGN Expr
AssignStat ::=  ID ASSIGN Expr: expr_
        {:
            RESULT = new AssignStat(expr_left, expr_right, expr_);
        :}
        ;



//CallFun ::= ID LPAR ExprList RPAR
  //        | ID LPAR RPAR
  CallFun ::= ID:id_ LPAR ExprList:exprlist_ RPAR
        {:
            RESULT = new CallFun(id_left, id_right, id_, exprlist_);
        :}
        |
        ID:id_ LPAR RPAR
        {:
            RESULT = new CallFun(id_left, id_right, id_);
        :}
        ;




//ExprList ::= Expr
  //        | Expr COMMA ExprList
  //        | OUTPAR ID
  //        | OUTPAR ID COMMA ExprList
ExprList::= Expr:expr_
        {:
            RESULT = new ArrayList<Expr,Id>();
            RESULT.add(expr_);
        :}
        |
        Expr:expr_ COMMA ExprList:exprlist_
        {:
            exprlist_.add(expr_);
            RESULT = exprlist_;
        :}
        |
        OUTPAR ID:Id_
        {:
            RESULT = new ArrayList<Expr,Id>();
            RESULT.add(Id_);
        :}
        |
        OUTPAR ID:Id_ COMMA ExprList:exprlist_
        {:
            exprlist_.add(Id_);
            RESULT = exprlist_;
        :}
        ;

Expr ::= TRUE:true_
        {:
            RESULT = new BooleanConst(true_left, true_right, true);
        :}
        |
        FALSE:false_
        {:
            RESULT = new BooleanConst(false_left, false_right, false);
        :}
        |
        INTEGER_CONST:intconst_
        {:
            RESULT = new IntegerConst(intconst_left, intconst_right, intconst_);
        :}
        |
        REAL_CONST:realconst_
        {:
            RESULT = new RealConst(realconst_left, realconst_right, realconst_);
        :}
        |
        STRING_CONST:stringconst_
        {:
            RESULT = new StringConst(stringconst_left, stringconst_right, stringconst_);
        :}
        |
        ID:id_
        {:
            RESULT = new Id(id_left, id_right, id_);
        :}
        |
        CallFun:callfun_
        {:
            RESULT = new CallingFun(callfun_left,callfun_right,callfun_);
        :}
        |
        Expr:expr_ PLUS Expr:expr1_
        {:
            RESULT = new PlusOperation(expr_left,expr_right,expr_,expr1_);
        :}
        |
        Expr:expr_ MINUS Expr:expr1_
        {:
            RESULT = new MinusOperation(expr_left,expr_right,expr_,expr1_);
        :}
        |
        Expr:expr_ TIMES Expr:expr1_
        {:
            RESULT = new TimesOperation(expr_left,expr_right,expr_,expr1_);
        :}
        |
        Expr:expr_ DIV Expr:expr1_
        {:
            RESULT = new DivOperation(expr_left,expr_right,expr_,expr1_);
        :}
        |
        Expr:expr_ DIVINT Expr:expr1_
        {:
            RESULT = new DivIntOperation(expr_left,expr_right,expr_,expr1_);
        :}
        |
        Expr:expr_ AND Expr:expr1_
        {:
            RESULT = new AndOperation(expr_left,expr_right,expr_,expr1_);
        :}
        |
        Expr:expr_ POW Expr:expr1_
        {:
            RESULT = new PowOperation(expr_left,expr_right,expr_,expr1_);
        :}
        |
        Expr:expr_ STR_CONCAT Expr:expr1_
        {:
            RESULT = new StringConcat(expr_left,expr_right,expr_,expr1_);
        :}
        |
        Expr:expr_ OR Expr:expr1_
        {:
            RESULT = new OrOperation(expr_left,expr_right,expr_,expr1_);
        :}
        |
        Expr:expr_ GT Expr:expr1_
        {:
            RESULT = new GreaterThan(expr_left,expr_right,expr_,expr1_);
        :}
        |
        Expr:expr_ GE Expr:expr1_
        {:
            RESULT = new GreaterEqual(expr_left,expr_right,expr_,expr1_);
        :}
        |
        Expr:expr_ LT Expr:Expr1_
        {:
            RESULT = new LessThan(expr_left,expr_right,expr_,expr1_);
        :}
        |
        Expr:expr_ LE Expr:Expr1_
        {:
            RESULT = new LessEqual(expr_left,expr_right,expr_,expr1_);
        :}
        |
        Expr:expr_ EQ Expr:expr1_
        {:
            RESULT = new Equal(expr_left,expr_right,expr_,expr1_);
        :}
        |
        Expr:expr_ NE Expr:expr1_
        {:
            RESULT = new NotEqual(expr_left,expr_right,expr_,expr1_);
        :}
        |
        UMINUS Expr:expr_
        {:
            RESULT = new UminusExpression(expr_left, expr_right, expr_);
        :}
        %prec UMINUS
        |
        NOT Expr:expr_
        {:
            RESULT = new NotExpression(expr_left, expr_right, expr_);
        :}
        |
        LPAR Expr:expr_ RPAR
        {:
            RESULT = new FunctionParam(expr_left, expr_right, expr_);
        :}
        ;