/*Specifiche grammaticali e lessicali del nostro linguaggio MyFun


  ************* Specifica grammaticale ****************

    Program ::= VarDeclList FunList Main

    VarDeclList ::= /* empty */
    /*	| VardDecl VarDeclList

    Main ::= MAIN VarDeclList StatList END MAIN SEMI

    FunList ::= /* empty */
    /*	| Fun FunList

    VarDecl ::= Type IdListInit SEMI
        | VAR IdListInitObbl SEMI

    Type ::= INTEGER | BOOL | REAL | STRING

    IdListInit ::= ID
        | IdListInit COMMA ID
        | ID ASSIGN Expr
        | IdListInit COMMA ID ASSIGN Expr

    IdListInitObbl ::= ID ASSIGN Const
        | IdListInitObbl COMMA ID ASSIGN Const

    Const ::= INTEGER_CONST | REAL_CONST | BOOL_CONST | STRING_CONST

    Fun := FUN ID LPAR ParamDeclList RPAR COLON Type
            VarDeclList StatList END FUN SEMI
        | FUN ID LPAR ParamDeclList RPAR
            VarDeclList StatList END FUN SEMI


    ParamDeclList ::= /*empty */
    /*	| NonEmptyParamDeclList

    NonEmptyParamDeclList ::= ParDecl
        | NonEmptyParamDeclList COMMA ParDecl

    ParDecl ::= Type ID
        | OUT Type ID

    StatList ::= Statement
         | Statement StatList

    Statement ::= IfStatement SEMI
        | WhileStatement SEMI
        | ReadStatement SEMI
        | WriteStatement SEMI
        | AssignStatement SEMI
        | CallFun SEMI
        | RETURN Expr SEMI
        | /* empty */
    /*
    IfStatement ::= IF Expr THEN VarDeclList StatList ElseStatement END IF

    ElseStatement ::= /* empty */
    /*	| ELSE VarDeclList  StatList

    WhileStatement ::= WHILE Expr LOOP VarDeclList  StatList END LOOP

    ReadStatement ::= READ IdList Expr // Expr deve essere di tipo stringa
        | READ IdList

    IdList ::= ID
        | IdList COMMA ID

    WriteStatement ::=  WRITE  Expr
        | WRITELN  Expr
        | WRITET  Expr
        | WRITEB  Expr


    AssignStatement ::=  ID ASSIGN Expr

    CallFun ::= ID LPAR ExprList RPAR
        | ID LPAR RPAR

    ExprList ::= Expr
        | Expr COMMA ExprList
        | OUTPAR ID
        | OUTPAR ID COMMA ExprList

    Expr ::= TRUE
        | FALSE
        | INTEGER_CONST
        | REAL_CONST
        | STRING_CONST
        | ID
        | CallFun
        | Expr  PLUS Expr
        | Expr  MINUS Expr
        | Expr  TIMES Expr
        | Expr  DIV Expr
        | Expr  DIVINT Expr
        | Expr  AND Expr
        | Expr POW Expr
        | Expr STR_CONCAT Expr
        | Expr  OR Expr
        | Expr  GT Expr
        | Expr  GE Expr
        | Expr  LT Expr
        | Expr  LE Expr
        | Expr  EQ Expr
        | Expr  NE Expr
        | MINUS Expr
        | NOT Expr
        | LPAR Expr RPAR
*/

package generated;
import java_cup.runtime.*;
import java.util.*;
import java.lang.Boolean;
import Node.*;
import Operation.*;
import Statement.*;

class Parser;

parser code{:

    public void report_error(String msg, Object info) {
      Symbol sym = (Symbol)info;
      System.out.println(msg + ": " + symbl_name_from_id(sym.sym));
    }

    public void syntax_error(Symbol s){
        System.out.println("compiler has detected a syntax error at line " + s.left
            + " column " + s.right);
    }

:}

/*Terminal*/
terminal String MAIN,
                ID,
               	INTEGER,
               	STRING,
               	REAL,
               	BOOL,
               	LPAR,
               	RPAR,
               	COLON,
               	FUN,
               	END,
               	IF,
               	THEN,
               	ELSE,
               	WHILE,
               	LOOP,
               	READ,
               	WRITE,
               	WRITELN,
               	WRITEB,
               	WRITET,
               	ASSIGN,
               	PLUS,
               	MINUS,
               	TIMES,
               	DIVINT,
               	DIV,
               	POW,
               	STR_CONCAT,
               	EQ,
               	NE,
               	LT,
               	LE,
               	GT,
               	GE,
               	AND,
               	OR,
               	NOT,
                STRING_CONST,
                SEMI,
               	COMMA,
               	NULL,
               	ERROR,
               	RETURN,
               	OUTPAR,
               	OUT,
               	VAR;

terminal String INTEGER_CONST;
terminal String REAL_CONST;
terminal String TRUE, FALSE;

//Non terminali

non terminal      Program         	             Program;
non terminal      ArrayList<VarDecl>             VarDeclList;
non terminal      Main                           Main;
non terminal      ArrayList<Fun>                 FunList;
non terminal      VarDecl                        VarDecl;
non terminal      Type                           Type;
non terminal      ArrayList<AssignStatement>     IdListInit;
non terminal      ArrayList<AssignStatement>     IdListInitObbl;
non terminal      ExprOp                         Const ;
non terminal      Fun                            Fun;
non terminal      ArrayList<ParDecl>             ParamDeclList;
non terminal      ArrayList<ParDecl>             NonEmptyParamDeclList ;
non terminal      ParDecl                        ParDecl;
non terminal      ArrayList<Statement>           StatList;
non terminal      Statement                      Stat;
non terminal      IfStatement                    IfStat;
non terminal      ElseStatement                  Else;
non terminal      WhileStatement                 WhileStat;
non terminal      ReadStatement                  ReadStat;
non terminal      WriteStatement                 WriteStat;
non terminal      AssignStatement                AssignStat;
non terminal      CallProcOp                     CallFun;
non terminal      ArrayList<ExprOp>              ExprList;
non terminal      ExprOp                         Expr;
non terminal      ArrayList<Id>                  IdList;

// Precendenze:: partendo dal basso (precedenza maggiore) a salire (precedenza minore)
precedence left OR;
precedence left AND;
precedence right NOT;
precedence nonassoc EQ, NE, LT, LE, GT, GE;
precedence left STR_CONCAT;
precedence left PLUS, MINUS;
precedence left TIMES,DIV, DIVINT;
precedence right POW;
precedence left LPAR, RPAR;

/*
Program ::= VarDeclList:varList ProcList:procList {:RESULT = new ProgramOp(varList,procList);:};

VarDeclList ::=   {:RESULT = new VarDeclListOp(new ArrayList<VarDeclOp>());:}
                |VarDecl:varDecl VarDeclList:varDecList {:RESULT = varDecList.add(varDecl);:}
                ;

ProcList ::=        {:RESULT = new ProcListOp(new ArrayList<ProcOp>());:}
             |Proc:Node ProcList:list{:RESULT = list.add(Node);:}
            ;

VarDecl ::= Type:t IdListInit:list SEMI {:RESULT = new VarDeclOp(t,list);:}
            ;

Type ::= INT:i {:RESULT = new TypeOp("int");:}
         |BOOL:b {:RESULT = new TypeOp("bool");:}
         |FLOAT:f {:RESULT = new TypeOp("float");:}
         |STRING:s {:RESULT = new TypeOp("string");:}
         ;

IdListInit ::= 	ID:id {:
                        HashMap<String,ExprOp> list = new HashMap<String,ExprOp>();
                        list.put(id,new ExprOp(new Null()));
                        RESULT = new IdListInitOp(list);
                      :}
			|IdListInit:list COMMA ID:id {:RESULT = list.put(id,new ExprOp(new Null()));:}
			|ID:id ASSIGN Expr:e {:
			                         HashMap<String,ExprOp> list = new HashMap<String,ExprOp>();
			                         list.put(id,e);
                                     RESULT = new IdListInitOp(list);
                                   :}
			|IdListInit:list COMMA ID:id ASSIGN Expr:e {:
			                                             RESULT = list.put(id,e);
			                                           :}
			;

Proc ::= 	PROC ID:id LPAR ParamDeclList:paramList RPAR ResultTypeList:resultList COLON VarDeclList:varList StatList:statList RETURN ReturnExprs:returnExprs CORP SEMI{:RESULT = new ProcOp(id,paramList, resultList,  varList,  statList,  returnExprs);:}
			|PROC ID:id LPAR RPAR ResultTypeList:resultList COLON VarDeclList:varList StatList:statList RETURN ReturnExprs:returnExprs CORP SEMI{:  ArrayList<ParDeclOp> l = new ArrayList<ParDeclOp>();
			                                                                                                                                        l.add(new ParDeclOp(new TypeOp("Void")));
			                                                                                                                                        ParamDeclListOp param = new ParamDeclListOp(l);
			                                                                                                                                        RESULT = new ProcOp( id,  param,  resultList,  varList,  returnExprs);:}
			|PROC ID:id LPAR ParamDeclList:paramList RPAR ResultTypeList:resultList COLON VarDeclList:varList RETURN ReturnExprs:returnExprs CORP SEMI{:RESULT = new ProcOp(id,paramList, resultList,  varList,  returnExprs);:}
			|PROC ID:id LPAR RPAR ResultTypeList:resultList COLON VarDeclList:varList RETURN ReturnExprs:returnExprs CORP SEMI{:ArrayList<ParDeclOp> l = new ArrayList<ParDeclOp>();
                                                                                                                                l.add(new ParDeclOp(new TypeOp("Void")));
                                                                                                                                ParamDeclListOp param = new ParamDeclListOp(l);
                                                                                                                                RESULT = new ProcOp( id,  param,  resultList,  varList,  null,  returnExprs);:}
			;

ResultTypeList ::= 	ResultType:r {:
                                   ArrayList<ResultTypeOp> list = new ArrayList<ResultTypeOp>();
                                   list.add(r);
                                   RESULT = new ResultTypeListOp(list);
                                  :}
					|ResultType:r COMMA ResultTypeList:list {:RESULT = list.add(r);:}
					;

ReturnExprs ::= ExprList:list {:RESULT = new ReturnExprsOp(list);:}
                |{:RESULT = null;:}
                ;

ExprList ::=   Expr:e {:
                        ArrayList<ExprOp> l = new ArrayList<ExprOp>();
                        l.add(0,e);
                        RESULT = new ExprListOp(l);
                       :}
                |Expr:e COMMA ExprList:list {:RESULT = list.add(e);:}
                ;

ParamDeclList ::= ParDecl:Node {:
                                ArrayList<ParDeclOp> l = new ArrayList<ParDeclOp>();
                                l.add(0,Node);
                                RESULT = new ParamDeclListOp(l);
                             :}
                  |ParamDeclList:list SEMI ParDecl:Node {:RESULT = list.add(Node);:}
                  ;

ParDecl ::= Type:t IdList:list {:RESULT = new ParDeclOp(t,list);:}
            ;

IdList ::= ID:id {:
                    ArrayList<String> l = new ArrayList<String>();
                    l.add(0,id);
                    RESULT = new IdListOp(l);
                 :}
           |IdList:list COMMA ID:id {:RESULT = list.add(id);:}
           ;

ResultType ::= Type:t {:RESULT = new ResultTypeOp(t);:}
              |VOID:v {:RESULT = new ResultTypeOp(new TypeOp("void"));:}
                ;

//STATEMENT

StatList ::= Stat:stat {:
                         ArrayList l = new ArrayList<Statement>();
                         l.add(0,stat);
                         RESULT = new StatListOp(l);
                       :}
            | Stat:stat StatList:list {:RESULT = list.add(stat);:}
            ;

Stat ::=	AssignStat:assign SEMI      {:RESULT = new StatOp(assign);:}
			|CallProc:call SEMI         {:RESULT = new StatOp(call);:}
            |ReadlnStat:read SEMI       {:RESULT = new StatOp(read);:}
            |WriteStat:write SEMI       {:RESULT = new StatOp(write);:}
            |WhileStat:whileStat SEMI   {:RESULT = new StatOp(whileStat);:}
            |IfStat:ifStat SEMI	        {:RESULT = new StatOp(ifStat);:}
			;

IfStat ::= IF Expr:e THEN StatList:statList ElifList:elifList Else:elseStat FI {:RESULT = new IfStatOp(e,statList,elifList,elseStat);:}
           ;

ElifList ::= {:RESULT = new ElifListOp(new ArrayList<ElifOp>());:}
             |Elif:elif ElifList:list {:RESULT = list.add(elif);:}
             ;

Elif ::= ELIF Expr:e THEN StatList:list {:RESULT = new ElifOp(e,list);:}
        ;

Else ::= {:RESULT = null;:} //empty
         |ELSE StatList:list {:RESULT = new ElseOp(list);:}
         ;

WhileStat ::=   WHILE StatList:list1 RETURN Expr:e DO StatList:list2 OD {:RESULT = new WhileStatOp(e,list1,list2);:}
                |WHILE Expr:e DO StatList:list OD {:RESULT = new WhileStatOp(e,list);:}
                ;

ReadlnStat ::= READ LPAR IdList:list RPAR  {:RESULT = new ReadlnStatOp(list);:}
                ;

WriteStat ::= WRITE LPAR ExprList:list RPAR {:RESULT = new WriteStatOp(list);:}
                ;

AssignStat ::= IdList:idList ASSIGN ExprList:exprList {:RESULT = new AssignStatOp(idList,exprList);:}
                ;

//CHIAMATA PROCEDURA

CallProc ::=    ID:id LPAR ExprList:list RPAR {:RESULT = new CallProcOp(id,list);:}
                |ID:id LPAR RPAR   {:RESULT = new CallProcOp(id);:}
                ;

*/

//ESPRESSIONI

Expr ::= TRUE:value {:RESULT = new ExprOp(value);:}
        |FALSE:value {:RESULT = new ExprOp(value);:}
        |INTEGER_CONST:intConst {:RESULT = new ExprOp(intConst);:}
        |REAL_CONST:floatConst {:RESULT = new ExprOp(floatConst);:}
        |STRING_CONST:string {:RESULT = new ExprOp(string);:}
        |ID:id  {:RESULT = new ExprOp(new Id(id));:}
        |Expr:e1 PLUS Expr:e2 {:RESULT = new ExprOp(new AddOp(e1,e2));:}
        |Expr:e1 MINUS Expr:e2  {:RESULT = new ExprOp(new DiffOp(e1,e2));:}
        |Expr:e1 TIMES Expr:e2  {:RESULT = new ExprOp(new MulOp(e1,e2));:}
        |Expr:e1 DIV Expr:e2    {:RESULT = new ExprOp(new DivOp(e1,e2));:}
        |Expr:e1 DIVINT Expr:e2    {:RESULT = new ExprOp(new DivIntOp(e1,e2));:}
        |Expr:e1 AND Expr:e2  {:RESULT = new ExprOp(new AndOp(e1,e2));:}
        |Expr:e1 OR Expr:e2   {:RESULT = new ExprOp(new OrOp(e1,e2));:}
        |Expr:e1 GT Expr:e2   {:RESULT = new ExprOp(new GtOp(e1,e2));:}
        |Expr:e1 GE Expr:e2   {:RESULT = new ExprOp(new GeOp(e1,e2));:}
        |Expr:e1 LT Expr:e2   {:RESULT = new ExprOp(new LtOp(e1,e2));:}
        |Expr:e1 LE Expr:e2   {:RESULT = new ExprOp(new LeOp(e1,e2));:}
        |Expr:e1 EQ Expr:e2   {:RESULT = new ExprOp(new EqOp(e1,e2));:}
        |Expr:e1 NE Expr:e2   {:RESULT = new ExprOp(new NeOp(e1,e2));:}
        |NOT Expr:e           {:RESULT = new ExprOp(new NotOp(e));:}
        |CallFun:c           {:RESULT = new ExprOp(c);:}
        ;