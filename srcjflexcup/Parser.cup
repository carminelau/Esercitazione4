/*Specifiche grammaticali e lessicali del nostro linguaggio MyFun


  ************* Specifica grammaticale ****************

    Program ::= VarDeclList FunList Main

    VarDeclList ::= /* empty */
    /*	| VardDecl VarDeclList

    Main ::= MAIN VarDeclList StatList END MAIN SEMI

    FunList ::= /* empty */
    /*	| Fun FunList

    VarDecl ::= Type IdListInit SEMI
        | VAR IdListInitObbl SEMI

    Type ::= INTEGER | BOOL | REAL | STRING

    IdListInit ::= ID
        | IdListInit COMMA ID
        | ID ASSIGN Expr
        | IdListInit COMMA ID ASSIGN Expr

    IdListInitObbl ::= ID ASSIGN Const
        | IdListInitObbl COMMA ID ASSIGN Const

    Const ::= INTEGER_CONST | REAL_CONST | BOOL_CONST | STRING_CONST

    Fun := FUN ID LPAR ParamDeclList RPAR COLON Type
            VarDeclList StatList END FUN SEMI
        | FUN ID LPAR ParamDeclList RPAR
            VarDeclList StatList END FUN SEMI


    ParamDeclList ::= /*empty */
    /*	| NonEmptyParamDeclList

    NonEmptyParamDeclList ::= ParDecl
        | NonEmptyParamDeclList COMMA ParDecl

    ParDecl ::= Type ID
        | OUT Type ID

    StatList ::= Statement
         | Statement StatList

    Statement ::= IfStatement SEMI
        | WhileStatement SEMI
        | ReadStatement SEMI
        | WriteStatement SEMI
        | AssignStatement SEMI
        | CallFun SEMI
        | RETURN Expr SEMI
        | /* empty */
    /*
    IfStatement ::= IF Expr THEN VarDeclList StatList ElseStatement END IF

    ElseStatement ::= /* empty */
    /*	| ELSE VarDeclList  StatList

    WhileStatement ::= WHILE Expr LOOP VarDeclList  StatList END LOOP

    ReadStatement ::= READ IdList Expr // Expr deve essere di tipo stringa
        | READ IdList

    IdList ::= ID
        | IdList COMMA ID

    WriteStatement ::=  WRITE  Expr
        | WRITELN  Expr
        | WRITET  Expr
        | WRITEB  Expr


    AssignStatement ::=  ID ASSIGN Expr

    CallFun ::= ID LPAR ExprList RPAR
        | ID LPAR RPAR

    ExprList ::= Expr
        | Expr COMMA ExprList
        | OUTPAR ID
        | OUTPAR ID COMMA ExprList

    Expr ::= TRUE
        | FALSE
        | INTEGER_CONST
        | REAL_CONST
        | STRING_CONST
        | ID
        | CallFun
        | Expr  PLUS Expr
        | Expr  MINUS Expr
        | Expr  TIMES Expr
        | Expr  DIV Expr
        | Expr  DIVINT Expr
        | Expr  AND Expr
        | Expr POW Expr
        | Expr STR_CONCAT Expr
        | Expr  OR Expr
        | Expr  GT Expr
        | Expr  GE Expr
        | Expr  LT Expr
        | Expr  LE Expr
        | Expr  EQ Expr
        | Expr  NE Expr
        | MINUS Expr
        | NOT Expr
        | LPAR Expr RPAR
*/


package generated;
import java_cup.runtime.*;
import java.util.*;
import syntax.*;
import syntax.statement.*;
import syntax.expression.*;
import syntax.expression.binary.arithmetic.*;
import syntax.expression.binary.relation.*;
import syntax.expression.unary.*;
import syntax.expression.constant.*;
import syntax.types.*;
import java.lang.Boolean;


class Parser;

parser code{:

    public void report_error(String msg, Object info) {
      Symbol sym = (Symbol)info;
      System.out.println(msg + ": " + symbl_name_from_id(sym.sym));
    }

    public void syntax_error(Symbol cur_token) {
      System.out.println("Syntax error: " + symbl_name_from_id(cur_token.sym));
    }

:}

/*Terminal*/
terminal String MAIN,
                ID,
               	INTEGER,
               	STRING,
               	REAL,
               	BOOL,
               	LPAR,
               	RPAR,
               	COLON,
               	FUN,
               	END,
               	IF,
               	THEN,
               	ELSE,
               	WHILE,
               	LOOP,
               	READ,
               	WRITE,
               	WRITELN,
               	WRITEB,
               	WRITET,
               	ASSIGN,
               	PLUS,
               	MINUS,
               	TIMES,
               	DIVINT,
               	DIV,
               	POW,
               	STR_CONCAT,
               	EQ,
               	NE,
               	LT,
               	LE,
               	GT,
               	GE,
               	AND,
               	OR,
               	NOT,
               	NULL,
                STRING_CONST,
                BOOL_CONST,
                SEMI,
               	COMMA,
               	UMINUS,
               	RETURN,
               	OUTPAR,
               	OUT,
               	VAR;

terminal int INTEGER_CONST;
terminal float REAL_CONST;
terminal boolean TRUE, FALSE;

//Non terminali

non terminal      Program         	             Program;
non terminal      ArrayList<VarDecl>             VarDeclList;
non terminal      Main                           Main;
non terminal      ArrayList<Fun>                 FunList;
non terminal      VarDecl                        VarDecl;
non terminal      Type                           Type;
non terminal      ArrayList<AssignStatement>     IdListInit;
non terminal      ArrayList<AssignStatement>     IdListInitObbl;
non terminal      Expr                           Const ;
non terminal      Fun                            Fun;
non terminal      ArrayList<ParDecl>             ParamDeclList;
non terminal      ArrayList<ParDecl>             NonEmptyParamDeclList ;
non terminal      ParDecl                        ParDecl;
non terminal      ArrayList<Statement>           StatList;
non terminal      Statement                      Stat;
non terminal      IfStatement                    IfStat;
non terminal      ElseStatement                  Else;
non terminal      WhileStatement                 WhileStat;
non terminal      ReadStatement                  ReadStat;
non terminal      WriteStatement                 WriteStat;
non terminal      AssignStatement                AssignStat;
non terminal      CallingFun                     CallFun;
non terminal      ArrayList<Expr>                ExprList;
non terminal      Expr                           Expr;
non terminal      ArrayList<Id>                  IdList;

// Precendenze:: partendo dal basso (precedenza maggiore) a salire (precedenza minore)
precedence left OR;
precedence left AND;
precedence right NOT;
precedence nonassoc EQ, NE, LT, LE, GT, GE;
precedence left STR_CONCAT;
precedence left PLUS, MINUS;
precedence left TIMES,DIV, DIVINT;
precedence right POW;
precedence left LPAR, RPAR;


//Program ::= VarDeclList FunList Main
Program ::= VarDeclList:vardecllist_ FunList:funlist_ Main:main_
            {:
                RESULT = new Program(main_left,main_right,vardecllist_,funlist_,main_);
            :}
            ;

// Main ::= MAIN VarDeclList StatList END MAIN SEMI
Main ::= MAIN VarDeclList:vardecllist_ StatList:statlist_ END MAIN SEMI
        {:
            RESULT= new Main(vardecllist_left,vardecllist_right, vardecllist_, statlist_);
        :}
        ;

// VarDeclList ::= empty  | VardDecl VarDeclList /*
VarDeclList ::= VarDecl:vardecl_ VarDeclList:vardecllist_
                {:
                    vardecllist_.add(vardecl_);
                    RESULT = vardecllist_;
                :}
                |
                //epsilon
                ;

// FunList ::= Fun FunList
//    |  empty

FunList ::= Fun:fun_ FunList:funlist_
            {:
                funlist_.add(fun_);
                RESULT = funlist_;
            :}
            |
            //epsilon
            ;

// VarDecl ::= Type IdListInit SEMI
//        | VAR IdListInitObbl SEMI

VarDecl ::= Type:type_  IdListInit:idlistinit_ SEMI
            {:
                RESULT = new VarDecl(type_left,type_right,type_, idlistinit_);
            :}
            |
            VAR IdListInitObbl:idlistobbl_ SEMI
            {:
                RESULT = new VarDecl(idlistobbl_left, idlistobbl_right, idlistobbl_);
            :}
            ;

// Const ::= INTEGER_CONST | REAL_CONST | TRUE | FALSE | STRING_CONST
Const ::= INTEGER_CONST:int_
        {:
            RESULT = new IntegerConst(int_left, int_right, int_);
        :}
        |
        REAL_CONST:realconst_
        {:
            RESULT = new RealConst(realconst_left, realconst_right, realconst_);
        :}
        |
        TRUE:true_
        {:
            RESULT = new BooleanConst(true_left, true_right, true);
        :}
        |
        FALSE:false_
        {:
            RESULT = new BooleanConst(false_left, false_right, false);
        :}
        |
        STRING_CONST:stringconst_
        {:
            RESULT = new StringConst(stringconst_left, stringconst_right, stringconst_);
        :}
        ;


//Fun := FUN ID LPAR ParamDeclList RPAR COLON Type
  //            VarDeclList StatList END FUN SEMI
  //        | FUN ID LPAR ParamDeclList RPAR
  //            VarDeclList StatList END FUN SEMI
 Fun ::= FUN:fun_ ID:Id_ LPAR ParamDeclList: paramdeclist_ RPAR COLON Type:type_ VarDeclList: vardeclist_ StatList: statlist_ END FUN SEMI
        {:
            RESULT = new Fun(fun_left, fun_right, new Id(Id_left,Id_right,Id_),paramdeclist_, type_, vardeclist_, statlist_);
        :}
        |
        FUN:fun_ ID:Id_ LPAR ParamDeclList: paramdeclist_ RPAR VarDeclList:vardeclist_ StatList:statlist_ END FUN SEMI
        {:
            RESULT = new Fun(fun_left,fun_right, new Id(Id_left,Id_right,Id_), paramdeclist_, vardeclist_,statlist_);
        :}
        ;

        //ParamDeclList ::= empty
        //         | NonEmptyParamDeclList
ParamDeclList ::= NonEmptyParamDeclList: nonemptyparamdeclist_
        {:
            RESULT = nonemptyparamdeclist_;
        :}
        |
        //EPSILON
        ;

//NonEmptyParamDeclList ::= ParDecl
  //        | NonEmptyParamDeclList COMMA ParDecl
NonEmptyParamDeclList ::= ParDecl: pardecl_
        {:
            RESULT = new ArrayList<ParDecl>();
            RESULT.add(pardecl_);
        :}
        |
        NonEmptyParamDeclList: nonemptyparamdeclist_ COMMA ParDecl: pardecl_
        {:
            nonemptyparamdeclist_.add(pardecl_);
            RESULT = nonemptyparamdeclist_;
        :}
        ;

        // ParDecl ::= Type ID
          //        | OUT Type ID
ParDecl::= Type: type_ ID:id_
        {:
            RESULT = new ParDecl(type_left, type_right, type_,new Id(id_left,id_right,id_));
        :}
        |
        OUT:out_ Type: type_ ID:id_
        {:
            RESULT = new ParDecl(out_left, out_right, type_,new Id(id_left,id_right,id_));
        :}
        ;

//Type ::= INTEGER | BOOL | REAL | STRING
Type ::= INTEGER:int_
    {:
        RESULT = new PrimitiveType(int_left,int_right,"INTEGER");
    :}
    |
    BOOL:bool_
    {:
        RESULT = new PrimitiveType(bool_left,bool_right,"BOOL");
    :}
    |
    REAL:real_
    {:
        RESULT =new PrimitiveType(real_left,real_right,"REAL");
    :}
    |
    STRING:string_
    {:
        RESULT = new PrimitiveType(string_left,string_right,"STRING");
    :}
    ;

//IdListInit ::= ID
//      | IdListInit COMMA ID
//      | ID ASSIGN Expr
//      | IdListInit COMMA ID ASSIGN Expr

IdListInit ::= ID:id_
    {:
        RESULT = new ArrayList<AssignStatement>();
        RESULT.add(new AssignStatement(id_left,id_right,new Id(id_left,id_right, id_)));
    :}
    |
    IdListInit:idlistinit COMMA ID:id_
    {:
        idlistinit.add(new AssignStatement(id_left,id_right,new Id(id_left,id_right, id_)));
        RESULT = idlistinit;
    :}
    |
    ID:id_ ASSIGN Expr:expr_
    {:
        RESULT = new ArrayList<AssignStatement>();
        RESULT.add(new AssignStatement(id_left,id_right,new Id(id_left,id_right, id_), expr_));
    :}
    |
    IdListInit:idlistinit_ COMMA ID:id_ ASSIGN Expr:expr_
    {:
        idlistinit_.add(new AssignStatement(id_left,id_right,new Id(id_left,id_right, id_), expr_));
        RESULT = idlistinit_;
    :}
    ;

//  IdListInitObbl ::= ID ASSIGN Const
//      | IdListInitObbl COMMA ID ASSIGN Const

IdListInitObbl ::= ID:id_ ASSIGN Const:const_
    {:
        RESULT = new ArrayList<AssignStatement>();
        RESULT.add(new AssignStatement(id_left,id_right,new Id(id_left,id_right, id_), const_));
    :}
    |
    IdListInitObbl:idlistinitobbl_ COMMA ID:id_ ASSIGN Const:const_
    {:
        idlistinitobbl_.add(new AssignStatement(id_left,id_right,new Id(id_left,id_right, id_), const_));
        RESULT = idlistinitobbl_;
    :}
    ;



//StatList ::= Stat
  //         | Stat StatList
// StatList::= Stat:stat_
//    {:
//        RESULT = new ArrayList<Statement>();
//        RESULT.add(stat_);
//    :}
//    |
//    Stat:stat_ StatList: statlist_
//    {:
//        statlist_.add(stat_);
//        RESULT = statlist_;
//    :}
//    ;


//Stat ::= IfStat SEMI
  //        | WhileStat SEMI
  //        | ReadStat SEMI
  //        | WriteStat SEMI
  //        | AssignStat SEMI
  //        | CallFun SEMI
  //        | RETURN Expr SEMI
  //        | empty


Stat ::= IfStat: ifstat_ SEMI
        {:
            RESULT = new IfStatement(ifstat_left,ifstat_right);
        :}
    |
    WhileStat: whilestat_ SEMI
        {:
            RESULT = new WhileStatement(whilestat_left, whilestat_right);
        :}
    |
    ReadStat: readstat_ SEMI
        {:
            RESULT = new ReadStatement(readstat_left, readstat_right);
        :}
        |
    WriteStat: writestat_ SEMI
        {:
            RESULT = new WriteStatement(writestat_left, writestat_right);
        :}
        |
    AssignStat: assignstat_ SEMI
        {:
            RESULT = new AssignStatement(assignstat_left, assignstat_right);
        :}
        |
    CallFun: callfun_ SEMI
        {:
            RESULT = new CallingFunStatement(callfun_left,callfun_right, callfun_) ;
        :}
        |
    RETURN Expr:expr_ SEMI
        {:
            RESULT = new ReturnStatement(expr_left, expr_right, expr_);
        :}
        |
        //epsilon
        ;

//IfStatement ::= IF Expr THEN VarDeclList StatList ElseStatement END IF
IfStat::= IF Expr:expr_ THEN VarDeclList:vardecllist_ StatList: statlist_ Else:else_Stat_ END IF
        {:
            RESULT = new IfStatement(expr_left, expr_right, expr_, vardecllist_, statlist_, else_Stat_);
        :}
        ;

//ElseStatement ::=  empty
//	| ELSE VarDeclList  StatList
Else::= ELSE VarDeclList: vardecllist_ StatList: statlist_
        {:
            RESULT = new ElseStatement(vardecllist_left, vardecllist_right, vardecllist_, statlist_);
        :}
        |
        //epsilon
        ;

// WhileStatement ::= WHILE Expr LOOP VarDeclList  StatList END LOOP
WhileStat::= WHILE Expr:expr_ LOOP VarDeclList: vardecllist_ StatList: statlist_ END LOOP
        {:
            RESULT = new WhileStatement(expr_left, expr_right, expr_, vardecllist_, statlist_);
        :}
        ;

//    ReadStatement ::= READ IdList Expr // Expr deve essere di tipo stringa
//        | READ IdList
ReadStat ::= READ IdList:idlist_ Expr:expr_
        {:
            RESULT = new ReadStatement(idlist_left,idlist_right,idlist_,expr_);
        :}
        ;


//    IdList ::= ID
//        | IdList COMMA ID
IdList::= ID:id_
        {:
            RESULT = new ArrayList<Id>();
            RESULT.add(new Id(id_left,id_right , id_));
        :}
        |
        IdList:idlist_ COMMA ID:id_
        {:
            RESULT.add(new Id(id_left,id_right , id_));
        :}
        ;

//WriteStatement ::=  WRITE  Expr
  //        | WRITELN  Expr
  //        | WRITET  Expr
  //        | WRITEB  Expr
WriteStat ::=  WRITE  Expr:expr_
        {:
            RESULT = new WriteStatement(expr_left, expr_right, expr_);
        :}
        |
        WRITELN  Expr:expr_
        {:
            RESULT = new WriteStatement(expr_left, expr_right, expr_);
        :}
        |
        WRITET  Expr:expr_
        {:
            RESULT = new WriteStatement(expr_left, expr_right, expr_);
        :}
        |
        WRITEB  Expr:expr_
        {:
            RESULT = new WriteStatement(expr_left, expr_right, expr_);
        :}
        ;


//AssignStatement ::=  ID ASSIGN Expr
AssignStat ::=  ID:id_ ASSIGN Expr: expr_
        {:
            RESULT = new AssignStatement(expr_left, expr_right,new Id(id_left,id_right,id_),expr_);
        :}
        ;



//CallFun ::= ID LPAR ExprList RPAR
  //        | ID LPAR RPAR
CallFun ::= ID:id_ LPAR ExprList:exprlist_ RPAR
        {:
            RESULT = new CallingFun(exprlist_left, exprlist_right, new Id(id_left,id_right,id_), exprlist_);
        :}
        |
        ID:id_ LPAR RPAR
        {:
            RESULT = new CallingFun(id_left, id_right, new Id(id_left,id_right,id_));
        :}
        ;


//ExprList ::= Expr
  //        | Expr COMMA ExprList
  //        | OUTPAR ID
  //        | OUTPAR ID COMMA ExprList
ExprList::= Expr:expr_
        {:
            RESULT = new ArrayList<Expr>();
            RESULT.add(expr_);
        :}
        |
        Expr:expr_ COMMA ExprList:exprlist_
        {:
            exprlist_.add(expr_);
            RESULT = exprlist_;
        :}
        |
        OUTPAR ID:id_
        {:
            RESULT = new ArrayList<Expr>();
            RESULT.add(new Id(id_left, id_right, id_));
        :}
        |
        OUTPAR ID:id_ COMMA ExprList:exprlist_
        {:
            exprlist_.add(new Id(id_left, id_right, id_));
            RESULT = exprlist_;
        :}
        ;

Expr ::= TRUE:true_
        {:
            RESULT = new BooleanConst(true_left, true_right, true);
        :}
        |
        FALSE:false_
        {:
            RESULT = new BooleanConst(false_left, false_right, false);
        :}
        |
        INTEGER_CONST:intconst_
        {:
            RESULT = new IntegerConst(intconst_left, intconst_right, intconst_);
        :}
        |
        REAL_CONST:realconst_
        {:
            RESULT = new RealConst(realconst_left, realconst_right, realconst_);
        :}
        |
        STRING_CONST:stringconst_
        {:
            RESULT = new StringConst(stringconst_left, stringconst_right, stringconst_);
        :}
        |
        ID:id_
        {:
            RESULT = new Id(id_left, id_right, id_);
        :}
        |
        CallFun:callfun_
        {:
            RESULT = new CallingFun(callfun_left,callfun_right, callfun_);
        :}
        |
        Expr:expr_ PLUS Expr:expr1_
        {:
            RESULT = new PlusOperation(expr_left,expr_right,expr_,expr1_);
        :}
        |
        Expr:expr_ MINUS Expr:expr1_
        {:
            RESULT = new MinusOperation(expr_left,expr_right,expr_,expr1_);
        :}
        |
        Expr:expr_ TIMES Expr:expr1_
        {:
            RESULT = new TimesOperation(expr_left,expr_right,expr_,expr1_);
        :}
        |
        Expr:expr_ DIV Expr:expr1_
        {:
            RESULT = new DivOperation(expr_left,expr_right,expr_,expr1_);
        :}
        |
        Expr:expr_ DIVINT Expr:expr1_
        {:
            RESULT = new DivIntOperation(expr_left,expr_right,expr_,expr1_);
        :}
        |
        Expr:expr_ AND Expr:expr1_
        {:
            RESULT = new AndRelOperation(expr_left,expr_right,expr_,expr1_);
        :}
        |
        Expr:expr_ POW Expr:expr1_
        {:
            RESULT = new PowOperation(expr_left,expr_right,expr_,expr1_);
        :}
        |
        Expr:expr_ STR_CONCAT Expr:expr1_
        {:
            RESULT = new Str_ConcatOperation(expr_left,expr_right,expr_,expr1_);
        :}
        |
        Expr:expr_ OR Expr:expr1_
        {:
            RESULT = new OrRelOperation(expr_left,expr_right,expr_,expr1_);
        :}
        |
        Expr:expr_ GT Expr:expr1_
        {:
            RESULT = new GreatThanRelOperation(expr_left,expr_right,expr_,expr1_);
        :}
        |
        Expr:expr_ GE Expr:expr1_
        {:
            RESULT = new GreatThanEqualsRelOperation(expr_left,expr_right,expr_,expr1_);
        :}
        |
        Expr:expr_ LT Expr:expr1_
        {:
            RESULT = new LessThanRelOperation(expr_left,expr_right,expr_,expr1_);
        :}
        |
        Expr:expr_ LE Expr:expr1_
        {:
            RESULT = new LessThanEqualsRelOperation(expr_left,expr_right,expr_,expr1_);
        :}
        |
        Expr:expr_ EQ Expr:expr1_
        {:
            RESULT = new EqualsRelOperation(expr_left,expr_right,expr_,expr1_);
        :}
        |
        Expr:expr_ NE Expr:expr1_
        {:
            RESULT = new NotEqualsRelOperation(expr_left,expr_right,expr_,expr1_);
        :}
        |
        UMINUS Expr:expr_
        {:
            RESULT = new UminusExpression(expr_left, expr_right, expr_);
        :}
        %prec UMINUS
        |
        NOT Expr:expr_
        {:
            RESULT = new NotExpression(expr_left, expr_right, expr_);
        :}
        |
        LPAR Expr:expr_ RPAR
        {:
            RESULT = new FunctionParam(expr_left, expr_right, expr_);
        :}
        ;